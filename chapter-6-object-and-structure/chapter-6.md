# 6. 객체와 자료구조

### 자료 추상화

```text
public class Point {
    public double x;
    public double y;
}

public interface Point {
    double getX();
    double getY();
    void setCartesian(double x, double y);
}
```

한 클래스는 구현을 외부로 노출하고 다른 클래스는 구현을 완전히 숨긴다. 밑의 클래스는 자료 구조 이상을 표현한다. 클래스 메서드가 접근 정책을 강제한다. 좌표를 읽을 때에는 각 값을 개별적으로 읽고 좌표를 설정할 때는 두 값을 한꺼번에 설정해야 한다. 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. 구현을 감추려면 추상화가 필요하다. 그저 조회 함수와 설정 함수를 변수로 다룬다고 클래스가 되지는 않는다. 그보다는 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스라고 말할 수 있다.

### 자료/객체의 비대칭

\(자료 구조를 사용하는\) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. 

반대쪽도 참이다.

절차적인 코드는 새로운 자료구조를 추가하기 어렵다. 그러러면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러러면 모든 클래스를 고쳐야 한다.

분별 있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 안다. 때로는 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황이 있다. 

#### 잡종 구조

이런 혼란으로 때때로 절반은 객체, 절반은 자료구조인 잡종 구조가 나온다. 이런 잡종 구조는 양쪽 세상에서 단점만 모아놓은 구조이다. 그러므로 잡종 구조는 되도록 피하는 것이 좋다. 

### 결론

어떤 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견 없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다.





























